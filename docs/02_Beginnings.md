## Beginnings

* Back: [Introduction](01_Introduction.md)
* Next: [Transparent Computing](03_Transparent_computing.md)

I have long wanted to design and build my own processor from scratch. I learned
the basic components of how this works in college, but that was a while ago and
honestly I want to do something better than the basic stuff from my digital
electronics introduction class.

As I started working on this, I started trying to design an 8-bit instruction set,
mostly because I wanted to manage the complexity and have something I could actually
build in hardware at some point. It's possible to build an 8-bit computer from logic
gates with some time, money and effort. The most prominent example of this is
[Ben Eater](https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU).

However, as I worked through the details and went through the inevitable false starts
trying to work through my own instruction set design, I was inspired by the
Commodore 64, the best selling computer of all time. The 8-Bit Guy has a great series
on [Commodore history](https://www.youtube.com/playlist?list=PLfABUWdDse7Y6LLPlfsHKcvBCgqaudzVY)
on YouTube. Computers of that era were incredibly accessible to users. The machine
was at your disposal and with some effort you could learn how to control the
registers that affected the machines behavior. The 8-Bit Guy also did a video
describing his [ideal computer](https://www.youtube.com/watch?v=ayh0qebfD2g), and he
describes the essence of the greatness of computers of that era:

> Today when I think back to the computers that I was most fond of, it wasn't the
> Amiga. despite being much more powerful, the Amiga's operating system put a layer
> between the hardware and the end user.
>
> I still have a fondness for the 8-bit computers, and I don't have a particular
> favorite. I love writing code, and I'm just as happy to code on a VIC-20 a C64 or
> a Plus4 as long as it has that same closeness to the hardware.
>
> The 8-Bit Guy

This is really what I want to capture with uCISC. What if we re-imagined the personal
computer and brought forward that closeness to the hardware from that era while
throwing of the burden of backwards compatibility with x86, the 6502 or other
architectures.

#### Continue Reading

* Back: [Introduction](01_Introduction.md)
* Next: [Transparent Computing](03_Transparent_computing.md)


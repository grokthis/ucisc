# Compute Fibonacci numbers
#
# By default, computes fib(8) == 21. Change the imm on line 24
# to compute other numbers. fib(0x18) is the maximum value that
# will compute correctly. fib(0x19) and up will overflow 16-bits.
#
# To run:
#   $ exe/ucisc examples/fib.ucisc
#
# Instructions on the compiler and debugger are in the README.md
# Or use GitHub https://github.com/grokthis/ucisc-ruby#usage

Entry:
  # Initialize the stack register to 0x0000, decrement on push will change to 0xFFFF
  copy val 0 &stack

  fib(val 24)

  copy stack 0 &stack # Display on LEDs

finish:

  # Halt
  copy pc 0 pc

fib:
  # fib(0) == 0
  or stack 0 stack 0 flags
  {
    copy pc break pc !zero?


    # Return 0
    copy stack 1 &r2 pop  # Copy return address to R2, pop arg
    copy val 0 stack 0    # Copy 0 to return position
    copy &r2 0 pc         # Jump return
  } 

  # fib(1) == 1
  sub val 1 stack 0 flags
  {
    copy pc break pc !zero?

    # fib(1) = 1
    copy stack 1 &r2 pop  # Copy return address to R2, pop arg
    copy val 1 stack 0    # Copy 0 to return position
    copy &r2 0 pc         # Jump return
  }

  # Recurse for fib(arg-1) and fib(arg-2)
  {
    sub val 1 stack 0          # replace n with n - 1

    fib(stack 0)
    sub val 1 stack 1          # replace n - 1 with n - 2
    fib(stack 1)
  }

  copy stack 0 &r2 pop
  add stack 0 &r2 pop

  copy &stack 1 &stack         # Throw away n
  copy stack 0 &r3 pop         # Copy return address to r3
  copy &r2 0 stack 0 push      # Push fib(n) to stack

  copy &r3 0 pc                # Jump return

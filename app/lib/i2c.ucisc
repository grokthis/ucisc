# 14-segment LED positions for the various numbers
var val.zero/%3F
var val.one/%06
var val.two/%DB
var val.three/%CF
var val.four/%E6
var val.five/%ED
var val.six/%FD
var val.seven/%07
var val.eight/%FF
var val.nine/%EF
var val.A/%F7
var val.B/%BF
var val.C/%39
var val.D/%7F
var val.E/%F9
var val.F/%F1
var val.underscore/%08

def i2c/r6
var i2c.flags/1
var i2c.address/2
var i2c.remaining/3
var i2c.data/4

fun stack.i2c-setTarget(deviceId, target) {
  &i2c <- copy stack.deviceId

  stack.target <- shl val/1
  i2c.address <- copy stack.target
  pc <- copy stack.return pop
}

fun stack.i2c-initDevice(deviceId, target) {
  &i2c <- copy stack.deviceId
  # Speed mode 2
  i2c.flags/0 <- copy val/%0400

  stack.target <- shl val/1
  i2c.address <- copy stack.target

  i2c.data/0 <- swap val/%21
  i2c.remaining/0 <- copy val/1

  stack.i2c-wait()

  i2c.data/0 <- swap val/%81
  i2c.remaining/0 <- copy val/1

  stack.i2c-wait()

  pc <- copy stack.return pop
}

fun stack.i2c-wait() {
  stack.wait(val/%4C0)
  pc <- copy stack.return pop

  var stack.test/0 push <- copy val/0

  {
    stack.test <- copy i2c.remaining
    stack.test <~ add val/0

    pc <|1 copy pc/loop
  }

  pc <- copy stack.return pop
}

fun stack.i2c-writeByte(deviceId, byteOffset, word) {
  &i2c <- copy stack.deviceId
  var stack.byte/0 <- copy stack.word
  var stack.byte/0 <- and val/%FF
  var stack.mask/0 <- swap val/%FF

  {
    stack.byteOffset <~ and val/%1
    pc <|0 copy pc/break

    stack.byte <- swap stack.byte
    stack.mask <- swap stack.mask
  }

  stack.byteOffset <- shr val/%1
  &i2c <- add stack.byteOffset

  stack.word <- copy i2c.data
  stack.word <- and stack.mask
  stack.word <- or stack.byte

  i2c.data <- copy stack.word

  pc <- copy stack.return pop
}

fun stack.i2c-writeWord(deviceId, byteOffset, word) {
  &i2c <- copy stack.deviceId
  {
    stack.byteOffset <~ and val/%1
    pc <|0 copy pc/break

    stack.i2c-writeByte(stack.deviceId, stack.byteOffset, stack.word)
    stack.byteOffset <- add val/1
    stack.word <- swap stack.word
    stack.i2c-writeByte(stack.deviceId, stack.byteOffset, stack.word)

    pc <- copy stack.return pop
  }

  stack.byteOffset <- shr val/%1
  &i2c <- add stack.byteOffset
  i2c.data <- copy stack.word

  pc <- copy stack.return pop
}

fun stack.i2c-flush(deviceId, bufferSize) {
  &i2c <- copy stack.deviceId
  i2c.remaining/0 <- copy stack.bufferSize
  stack.i2c-wait()
  pc <- copy stack.return pop
}

fun stack.i2c-printInt(deviceId, integer) {
  &i2c <- copy stack.deviceId
  stack.i2c-wait()

  var stack.ones/0 push <- copy val.zero
  var stack.tens/0 push <- copy val.zero
  var stack.hundreds/0 push <- copy val.zero
  var stack.thousands/0 push <- copy val.zero

  var stack.digit/0 push <- copy stack.integer
  var stack.index/0 push <- copy val/4
  {
    # Construct a switch statement with the offset jumping
    # directly to the proper int -> digit mapping
    stack.digit <- and val/%F
    # Note: 2 instructions @ 2 words each (4 total):
    stack.digit <- shl val/%2
    stack.digit <- add pc/lookup_digit
    pc <- copy stack.digit

    lookup_digit:
    {
      stack.digit <- copy val.zero
      pc <- copy pc/break
      stack.digit <- copy val.one
      pc <- copy pc/break
      stack.digit <- copy val.two
      pc <- copy pc/break
      stack.digit <- copy val.three
      pc <- copy pc/break
      stack.digit <- copy val.four
      pc <- copy pc/break
      stack.digit <- copy val.five
      pc <- copy pc/break
      stack.digit <- copy val.six
      pc <- copy pc/break
      stack.digit <- copy val.seven
      pc <- copy pc/break
      stack.digit <- copy val.eight
      pc <- copy pc/break
      stack.digit <- copy val.nine
      pc <- copy pc/break
      stack.digit <- copy val.A
      pc <- copy pc/break
      stack.digit <- copy val.B
      pc <- copy pc/break
      stack.digit <- copy val.C
      pc <- copy pc/break
      stack.digit <- copy val.D
      pc <- copy pc/break
      stack.digit <- copy val.E
      pc <- copy pc/break
      stack.digit <- copy val.F
    }

    stack.thousands <- copy stack.hundreds
    stack.hundreds <- copy stack.tens
    stack.tens <- copy stack.ones
    stack.ones <- copy stack.digit

    stack.integer <- shr val/4
    stack.digit <- copy stack.integer
    stack.index <- sub val/1
    pc <|1 copy pc/loop
  }

  i2c.data/0 <- copy stack.ones
  i2c.data/1 <- copy stack.tens
  i2c.data/2 <- copy stack.hundreds
  i2c.data/3 <- copy stack.thousands
  #stack.i2c-writeWord(val/%100, val/0, stack.ones)
  #stack.i2c-writeWord(val/%100, val/2, stack.tens)
  #stack.i2c-writeWord(val/%100, val/4, stack.hundreds)
  #stack.i2c-writeWord(val/%100, val/6, stack.thousands)
  stack.i2c-flush(stack.deviceId, val/10)

  pc <- copy stack.return pop
}

# Waits approximately the specified number of clock cycles
# If count is zero or negative, it returns after 3 clock cycles
# If count is positive and even, it returns after n + 1 cycles
# If count is positive and odd, it returns after n + 2 cycles
fun stack.wait(count) {
  {
    # Subtract 2 instructions each loop
    stack.count <- sub val/2
    pc <|+ copy pc/loop
  }

  pc <- copy stack.return pop
}

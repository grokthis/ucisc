# Bootloader that loads and executes code from a block device, usually a flash
# memory device. For information on block devices, see the programming guide:
# docs/programming_guide/2.2.3_Block_Memory_Device
#
# Usage: Define the configuration values in a ucisc source file.
# For example:
#   # Specify the address for code execution to start
#   var val.start/%0000
#
#   # Specify the address where the boot loader will run from
#   # must be more than 256 * loadBlockCount
#   var val.bootloaderRunAddress/%0F00
#
#   # Specify the block device ID to load from
#   var val.flashDevice/%40
#
#   # Specify the number of blocks to load from the block device
#   # Everything you need to run your code should be in these blocks
#   var val.loadBlockCount/4
#
# Process:
# 1. Execution starts at address 0x0000
# 2. This bootloader code copies itself to val.bootloaderRunAddress
# 3. Execution jumps to continue in the val.bootloaderRunAddress address block
# 4. The first val.loadBlockCount blocks of code/data are copied from the device
# 5. Execution jumps to val.start, handing execution to the loaded code
#
# This code depends on lib/mem_copy.ucisc
#
# To compile:
# ucisc -c load_config.ucisc \
#   app/core/bootloader.ucisc > bootloader.hex
def stack/r1 <- copy val/0

def flashDevice/r5 <- copy val.flashDevice
var flashDevice.deviceId/0
var flashDevice.config/1
var flashDevice.lowerAddress/2
var flashDevice.upperAddress/3
var flashDevice.status/5

# Enable read on flash device (up to 4-bit bus, fast mode)
flashDevice.config <- copy val/%3400

# Copy ourselves to the bootloader run address
stack.copyDeviceBlock(val.start, val/0, val.bootloaderRunAddress, val/0)

# Jump to the ContinueBootstrap location in the bootloader run space
var stack.continue/0 push <- copy pc/ContinueBootstrap
stack.continue <- add val.bootloaderRunAddress

pc <- copy stack.continue pop

ContinueBootstrap:

var stack.memAddress/0 push <- copy val.start
var stack.flashDeviceBlock/0 push <- copy val.flashDevice
stack.flashDeviceBlock/0 <- shl val/4

var stack.count/0 push <- copy val.loadBlockCount
flashDevice.lowerAddress <- copy val/%0
{
  {
    flashDevice.status <~ or val/0
    pc <|1 copy pc/loop
  }

  stack.copyDeviceBlock(stack.flashDeviceBlock, val/1, stack.memAddress, val/0)

  stack.count <- sub val/1
  pc <|0 copy pc/break

  flashDevice.lowerAddress <- add val/1
  stack.memAddress <- add val/%100

  pc <- copy pc/loop
}

pc <- copy val.start

# Copies an entire block of memory from one location to another
# Allows you to specify if the source/destination are devices or
# regular memory. This is the same as lib/mem_copy, but is directly
# included here to minimize bootloader size and remove external
# dependencies.
fun stack.copyDeviceBlock(fromAddress, fromDevice, toAddress, toDevice) {
  var stack.banking/0 push <- copy val/%70
  stack.fromDevice <~ add val/0
  stack.banking <|1 or val/2
  stack.toDevice <~ add val/0
  stack.banking <|1 or val/4

  banking <- copy stack.banking

  def a/r2 <- copy stack.fromAddress
  def b/r3 <- copy stack.toAddress

  var stack.i/0 push <- copy val/256
  {
    b <- copy a

    &a <- add val/1
    &b <- add val/1

    stack.i <- sub val/1
    pc <|1 copy pc/loop
  }

  # set banking back to defaults
  banking <- copy val/%70
  pc <- copy stack.return pop
}
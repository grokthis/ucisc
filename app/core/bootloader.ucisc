# Bootloader that loads and executes code from a block device.
# The device must be compatible with the SPI flash device.
#
# Usage: Define the proper values in a ucisc source file. For example:
#   var val.start/%0000                    # usually %0000
#   var val.bootloaderRunAddress/%0400     # must be > than 256 * loadBlockCount
#   var val.flashDevice/%40
#   var val.flashDeviceBlock/%4000
#   var val.loadBlockCount/4
#
# Process:
# 1. Execution starts at address val.start
# 2. This bootloader code copies itself to val.bootloaderRunAddress
# 3. Execution jumps to continue in the val.bootloaderRunAddress address block
# 4. The first val.loadBlockCount blocks of code/data are copied from the device
# 5. Execution jumps to val.start, handing execution to the loaded code
#
# This code depends on lib/mem_copy.ucisc
#
# To compile:
# ucisc -c load_config.ucisc \
#   app/core/bootloader.ucisc \
#   app/lib/mem_copy.ucisc > bootloader.hex

def stack/r1 <- copy val/0

def flashDevice/r5 <- copy val.flashDevice
var flashDevice.deviceId/0
var flashDevice.config/1
var flashDevice.lowerAddress/2
var flashDevice.upperAddress/3
var flashDevice.status/4

# Enable read on flash device
flashDevice.config <- copy val/%3400

# GPIO is on device 4
def gpio/r4 <- copy val/%40
var gpio.config/4
var gpio.pins_out/8

# Enable pin 1 as output, init GPIO out
gpio.config/0 <- copy val/1
gpio.pins_out/0 <- copy val/1

stack.i2c-initDevice(val/%100)

var stack.count/0 push <- copy val/0
{
  stack.i2c-printInt(val/%100, val/%123)
  stack.count <- add val/1
  stack.wait(val/%7FF)
  pc <- copy pc/0
}

stack.copyBlock(val.start, val.bootloaderRunAddress)

var stack.continue/0 push <- copy pc/ContinueBootstrap
stack.continue <- add val.bootloaderRunAddress

pc <- copy stack.continue pop
pc <- copy pc/0

ContinueBootstrap:

var stack.memAddress/0 push <- copy val.start
var stack.status/0 push <- copy flashDevice.status
var stack.flashDeviceBlock/0 push <- copy val.flashDevice
stack.flashDeviceBlock/0 <- shl val/4

{
  flashDevice.lowerAddress <- copy val/%0
  {
    # Flash device will have non-zero status until loaded
    #flashDevice.status <~ add val/0
    stack.status <- copy flashDevice.status
    stack.status <~ add val/0
    #&flashDevice <~ sub val.flashDevice
    pc <|1 copy pc/loop
  }
  gpio.pins_out/0 <- copy val/0

  stack.copyDeviceBlock(stack.flashDeviceBlock, val/1, stack.memAddress, val/0)
  gpio.pins_out/0 <- copy val/1
  #pc <- copy pc/0

  #stack.status <- copy flashDevice.lowerAddress
  #stack.status <- add val/1
  #flashDevice.lowerAddress <- copy stack.status
  #stack.memAddress <- add val/%100

  #stack.status <- copy flashDevice.lowerAddress
  #stack.status <~ sub val.loadBlockCount
  #flashDevice.lowerAddress <- copy val/%0
  pc <- copy pc/loop
  #pc <|- copy pc/loop
}

pc <- copy val.start
#var stack.next/0 push <- copy pc/ContinueBootstrap
#stack.next <- add val.bootloaderRunAddress
#pc <- copy stack.next pop

